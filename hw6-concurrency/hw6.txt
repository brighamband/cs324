PART 1: No Concurrency
1.    out:    USER         PID    PPID NLWP     LWP S CMD
              abrigham 1002769 1002375    1 1002769 S echoserveri
2.    There is 1 process and 1 thread running.  This is because no concurrency is happening, so there aren't any threads, they are all running on the same one.  So only the data sent from window 1 gets sent through, since that's the connection made.  The data from 2 and 3 doesn't get received yet since only 1 thread and process is running.
3.    The next nc process I started (window 2) was able to connect to the server and send off the bytes that I entered earlier.  They couldn't get sent off initially because the server was connected to the client in window 1, and the server only had the 1 thread.  So once that client connection stopped, the server could then go to window 2 (the next client making a request to the server) and receive its data.

PART 2: Process-based Concurrency
4.    out:    USER         PID    PPID NLWP     LWP S CMD
              abrigham 1005562 1002375    1 1005562 S echoserverp
              abrigham 1005605 1005562    1 1005605 S echoserverp
              abrigham 1005625 1005562    1 1005625 S echoserverp
              abrigham 1005644 1005562    1 1005644 S echoserverp
5.    For process-based, there are 4 separate processes running, each on their own thread.  It's clear looking at the PIDs and LWPs since they're all different.  In this process-based version, it handles client connections as different processes, which allows them all to concurrently send data to the server.

PART 3: Simple Thread-based Concurrency
6.    out:    USER         PID    PPID NLWP     LWP S CMD
              abrigham 1007040 1002375    4 1007040 S echoservert
              abrigham 1007040 1002375    4 1007088 S echoservert
              abrigham 1007040 1002375    4 1007208 S echoservert
              abrigham 1007040 1002375    4 1007261 S echoservert
7.    For simple thread-based, there is only 1 process running, and on that process there are 4 individual threads.  This is because they all have the same PID (meaning all 1 process) yet they have different LWPs.  In this thread-based version, it handles client connections all in the same process but on different threads.  Since they're all on different threads, they're able to still concurrently send data to the server.

PART 4: Threadpool-based Concurrency
8.    out:    USER         PID    PPID NLWP     LWP S CMD
              abrigham 1008413 1002375   11 1008413 S echoservert_pre
              abrigham 1008413 1002375   11 1008414 S echoservert_pre
              abrigham 1008413 1002375   11 1008415 S echoservert_pre
              abrigham 1008413 1002375   11 1008416 S echoservert_pre
              abrigham 1008413 1002375   11 1008417 S echoservert_pre
              abrigham 1008413 1002375   11 1008418 S echoservert_pre
              abrigham 1008413 1002375   11 1008419 S echoservert_pre
              abrigham 1008413 1002375   11 1008420 S echoservert_pre
              abrigham 1008413 1002375   11 1008421 S echoservert_pre
              abrigham 1008413 1002375   11 1008422 S echoservert_pre
              abrigham 1008413 1002375   11 1008423 S echoservert_pre
9.    This time there still is 1 process (all have the same PID) and on that process there are separate threads (11 this time).  With simple thread-based, it creates a new thread every time a new task needs executed, but with threadpool there's a set/max number of threads that just be used whenever new tasks need completed.  If there's too many tasks for the number of threads, then it will wait to finish current tasks until running those pending.

PART 5: Concurrency Review