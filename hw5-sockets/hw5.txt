Host Machine:     falcon
Client Machine:   usa

PART 1

1)
      a)  Technically getaddrinfo() is essential in setup as well, but socket() and connect() are the 2 main system calls used to prep the socket.
      b)  Without using a connect call, you could still have it work by using sendto() or sendmsg(), where you will just have to specify the destination since you aren't already connected to a socket.
            can you use getsockopt() and setsockopt() instead?  To still connect, but just not using connect()?
2)    
      ./server 2000
3)        
      a)    cmd:    ss -l -u -p -n "sport = :2000"
      b)    out:    State    Recv-Q   Send-Q     Local Address:Port      Peer Address:Port   Process
                    UNCONN   0        0                0.0.0.0:2000           0.0.0.0:*       users:(("server",pid=2103343,fd=3))
      c)    exp:    It's showing that it's showing a list of services listening from port 2000.  In our case it's just the one service running that we started when we ran the server file.  It gives the state, then tells us how much data is in the queue for the socket waiting to be read or sent.  It then has more port info.
4)
      a)    client cmd:       ./client -4 falcon 2000 foo bar baz catvideo
      b)    client out:       Sent 4 bytes to server
                              Received 4 bytes: foo
                              Sent 4 bytes to server
                              Received 4 bytes: bar
                              Sent 4 bytes to server
                              Received 4 bytes: baz
                              Sent 9 bytes to server
                              Received 9 bytes: catvideo
5)
      a)    4 write calls are made.
      b)    Just 1 datagram has been received (all receive operations return only 1 packet)
      c)    4 total calls are required (only 1 datagram can go through each call, so with 4 datagrams it will take 4 calls)
      d)    The cause of the inefficiency is that with UDP, it keeps datagrams in individual packets, so instead of receiving all the data at once, it has to receive each datagram one by one, which is less efficient.  Also, another inefficiency is that UDP is connectionless, so every time you want to send a datagram, you have to essentially temporarily reconnect to your destination again.

PART 2

6)    
      The role of the original socket changes because before it would just read each datagram, but now it keeps reading from the stream until it hits end of file.
7)    
      Before with UDP, connect in the client just basically set a destination to send to, but nothing would happen until the data was sent.  With the TCP version, connect actually performs the 3-way handshake beforehand, before actually sending any data.
8)    
      a)    cmd:        ss -l -t -p -n "sport = :2000"
      b)    out:        State   Recv-Q  Send-Q     Local Address:Port     Peer Address:Port  Process  
                        LISTEN  0       100              0.0.0.0:2000          0.0.0.0:*      users:(("server",pid=2239225,fd=3))
      c)    exp:        This time for TCP the output looked pretty similar to UDP, except this time instead of Send-Q being 0, Send-Q had a value of 100.  This makes sense intuitively, since UDP sent data over in packets over separate calls, so each time the server received a new packet from a call, it only knew of that call itself, meaning as far as each individual call was, it had no more to send by the end of a call (since it would send more in the next call).  With TCP however, since it reads with a buffer, here the server recognized that 100 more bits needed to be read.

9)    
      a)    cmd:        ./client -4 falcon 2000 foo bar baz catvideo
      b)    out:        Sent 4 bytes to server
                        Received 4 bytes: foo
                        Sent 4 bytes to server
                        Received 4 bytes: bar
                        Sent 4 bytes to server
                        Received 4 bytes: baz
                        Sent 9 bytes to server
                        Received 9 bytes: catvideo
10)
      a)    cmd:        ss -t -p -n "sport = :2000"
      b)    out:        State  Recv-Q  Send-Q     Local Address:Port     Peer Address:Port   Process  
                        ESTAB  0       0           192.168.2.73:2000     192.168.2.99:35030   users:(("server",pid=2239768,fd=4))
      c)    exp:        This time the state says that a connection has been established instead of listening, which makes sense since we only wanted to show active connections instead of just those listening.  The other interesting thing I saw is that now the local and peer addresses are not 0.0.0.0, but distinct addresses now.
11)
      a)    cmd:        ss -t -p -n "sport = :2000"
      b)    out:        State Recv-Q Send-Q  Local Address:Port   Peer Address:Port Process
      c)    exp:        Now that the socket connection was successfully established and successfully passed through the correct data, it closes the server, so therefore it won't show any active running TCP connections.
12)
      a)    /
      b)    /          
      c)    /
      d)    /

PART 3

13)   
      a)    /
      b)    /
14)   
      cmd:
      contents:
15)
      cmd:

PART 4

16)
      /
17)
      /
18)
      /
19)
      /
