Host Machine:     falcon
Client Machine:   usa

PART 1

1)
      a)  Technically getaddrinfo() is essential in setup as well, but socket() and connect() are the 2 main system calls used to prep the socket.
      b)  Without using a connect call, you could still have it work by using sendto() or sendmsg(), where you will just have to specify the destination since you aren't already connected to a socket.
            can you use getsockopt() and setsockopt() instead?  To still connect, but just not using connect()?
2)    
      ./server 2000
3)        
      a)    cmd:    ss -l -u -p -n "sport = :2000"
      b)    out:    State    Recv-Q   Send-Q     Local Address:Port      Peer Address:Port   Process
                    UNCONN   0        0                0.0.0.0:2000           0.0.0.0:*       users:(("server",pid=2103343,fd=3))
      c)    exp:    It's showing that it's showing a list of services listening from port 2000.  In our case it's just the one service running that we started when we ran the server file.  It gives the state, then tells us how much data is in the queue for the socket waiting to be read or sent.  It then has more port info.
4)
      a)    client cmd:       ./client -4 falcon 2000 foo bar baz catvideo
      b)    client out:       Sent 4 bytes to server
                              Received 4 bytes: foo
                              Sent 4 bytes to server
                              Received 4 bytes: bar
                              Sent 4 bytes to server
                              Received 4 bytes: baz
                              Sent 9 bytes to server
                              Received 9 bytes: catvideo
5)
      a)    4 write calls are made.
      b)    Just 1 datagram has been received (all receive operations return only 1 packet)
      c)    4 total calls are required (only 1 datagram can go through each call, so with 4 datagrams it will take 4 calls)
      d)    The cause of the inefficiency is that with UDP, it keeps datagrams in individual packets, so instead of receiving all the data at once, it has to receive each datagram one by one, which is less efficient.  Also, another inefficiency is that UDP is connectionless, so every time you want to send a datagram, you have to essentially temporarily reconnect to your destination again.

PART 2

6)    
      The role of the original socket changes because before it would just read each datagram, but now it keeps reading from the stream until it hits end of file.
7)    
      Before with UDP, connect in the client just basically set a destination to send to, but nothing would happen until the data was sent.  With the TCP version, connect actually performs the 3-way handshake beforehand, before actually sending any data.
8)    
      a)    cmd:        ss -l -t -p -n "sport = :2000"
      b)    out:        State   Recv-Q  Send-Q     Local Address:Port     Peer Address:Port  Process  
                        LISTEN  0       100              0.0.0.0:2000          0.0.0.0:*      users:(("server",pid=2239225,fd=3))
      c)    exp:        This time for TCP the output looked pretty similar to UDP, except this time instead of Send-Q being 0, Send-Q had a value of 100.  This makes sense intuitively, since UDP sent data over in packets over separate calls, so each time the server received a new packet from a call, it only knew of that call itself, meaning as far as each individual call was, it had no more to send by the end of a call (since it would send more in the next call).  With TCP however, since it reads with a buffer, here the server recognized that 100 more bits needed to be read.

9)    
      a)    cmd:        ./client -4 falcon 2000 foo bar baz catvideo
      b)    out:        Sent 4 bytes to server
                        Received 4 bytes: foo
                        Sent 4 bytes to server
                        Received 4 bytes: bar
                        Sent 4 bytes to server
                        Received 4 bytes: baz
                        Sent 9 bytes to server
                        Received 9 bytes: catvideo
10)
      a)    cmd:        ss -t -p -n "sport = :2000"
      b)    out:        State  Recv-Q  Send-Q     Local Address:Port     Peer Address:Port   Process  
                        ESTAB  0       0           192.168.2.73:2000     192.168.2.99:35030   users:(("server",pid=2239768,fd=4))
      c)    exp:        This time the state says that a connection has been established instead of listening, which makes sense since we only wanted to show active connections instead of just those listening.  The other interesting thing I saw is that now the local and peer addresses are not 0.0.0.0, but distinct addresses now.
11)
      a)    cmd:        ss -t -p -n "sport = :2000"
      b)    out:        State Recv-Q Send-Q  Local Address:Port   Peer Address:Port Process
      c)    exp:        Now that the socket connection was successfully established and successfully passed through the correct data, it closes the server, so therefore it won't show any active running TCP connections.
12)
      a)    4     (The client sends 4 writes to the server, one for each string, just like it did before)
      b)    4     (4 bytes because that's how much the first string is, then the other 17 will come after the first receive has been completed)     
      c)    2     (Unlike UDP that needs to make a call for each string that is sent, sending 4 total, this one sends them all to the server, then the server receives the first and the rest are stuck in a buffer on the server, then the server receives the remaining strings.  Therefore it takes 2 calls.
      d)    Instead of sending one string from the client, then receiving it in the server, then doing that over and over again until all strings have been sent from the client to the server (UDP), here TCP allows all the strings to be sent initially by the client, then the server just has them in a buffer and can read them in when it is able to.

PART 3

13)   
      a)    /
      b)    /
14)   
      cmd:
      contents:
15)
      cmd:

PART 4

16)
      If no datagrams/bytes are available at the client socket, it will wait (waits for message to arrive, unless it's non-blocking).
17)
      The excess bytes/datagrams will just be discarded if there's a longer length than the number of bytes ready.  This is because it can only receive up to the requested amount.
18)
      When the packet is smaller than the passed buffer, only that much data is returned, so it will only receive the datagram up to the length that you specified.
19)
      /
