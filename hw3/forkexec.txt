1.  The program is expecting an argument passed in which is the program to be run.  It starts out by printing the program name and its pid.  Then it sleeps for 30 seconds.  At that point, if there wasn't an argument provided, it prints the issue and exits.  If there was an argument, it calls execve on that argument passed in.  Execve will then run a new program.
2.  The final prinf will only be executed if a bad argument is passed in.  If no argument is passed in, it will print an error and exit.  If a good argument is passed in, it will run that program and won't return back to this one to print "End of program ...".  Only when a bad argument is passed in will it return to exec to print "End of program ...".
3.  Commands: ./exec /bin/cat
    Output: Program "./exec" has pid 2476743. Sleeping.
            Running exec of "/bin/cat"
            (Then it just reprints whatever is entered as input)
4.  Commands: ps -q 2481914 -o user,pid,ppid,state,ucmd
    Output (before):  USER      PID       PPID      S   CMD
                      abrigham  2481914   2472496   S   exec
    Output (after):   USER      PID       PPID      S   CMD
                      abrigham  2481914   2472496   S   cat
5.  Before and after, the commands have the same user, pid, ppd, and s.  However, they differ in their commands (before is exec, after is cat).  This happens because execve call the new process passed in and replaces the running process with it.  Because it's still the same process, the pid and ppid stay the same.
6.  Output: Program "./exec" has pid 2484788. Sleeping.
            No program to exec.  Exiting...
    This time, it runs the initial print statement that prints out exec (since that's the initial program being run) and its pid.  It then sleeps for 30 seconds.  After sleeping, it checks to see if an command line argument was passed in.  Since it received no arguments, it prints that there's no program to execute and exits.
7.  Fork.c starts the program and prints its pid.  Then it forks, and if there's an error forking (the forked process id is less than 0), it will print the error and exit.  Afterwards, it will print the parent id, then sleep 30 seconds.  Then it runs code in the child which prints section B, sleeps, prints done, then exits.  Section C is for the parent only, and that will run, doing exactly the same thing as B, but it sleeps for 60 seconds instead.  Lastly, both the parent and child run section D, which prints then sleeps 30 seconds.
8.  Section A - Parent & Child
    Section B - Child
    Section C - Parent
    Section D - Parent & Child